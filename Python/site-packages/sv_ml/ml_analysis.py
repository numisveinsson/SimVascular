# ML segmentation analysis

import sv

import os
import sys
import pdb
import json

SV_PATH = '/Users/numisveinsson/SimVascularProject/SimvascularSrc/Python/site-packages'
sys.path.append(SV_PATH)

from sv_ml import sv_wrapper

# Name of NN model
NET_FN = "googlenet_c30_train300k_aug10_clean"

# Path to image stack, 3D, .vti or DICOM or .mha
IMAGE_FN = "/Users/numisveinsson/Documents/Berkeley/Research/SimVascular/cases/0075_1001/Images/OSMSC0075-cm.vti"

# Path to pathline, .pth file
PATH_FN = '/Users/numisveinsson/Documents/Berkeley/Research/SimVascular/cases/0075_1001/Paths/aorta.pth'

# Load pathline

path_series = sv.pathplanning.Series(PATH_FN)

print("Paths:")
print("  Number of time steps: {0:d}".format(path_series.get_num_times()))

print(" ")
print("Path at time 0:")
actual_path = path_series.get_path(0)
control_points = actual_path.get_control_points()
print("  Number of control points: {0:d}".format(len(control_points)))
curve_points = actual_path.get_curve_points()
print("  Number of curve points: {0:d}".format(len(curve_points)))
# Test: get info on point nr. 20
point = actual_path.get_curve_point(20)
print("  Point 20: {0:s}".format(str(point)))
tangent = actual_path.get_curve_tangent(20)
print("  Tangent 20: {0:s}".format(str(tangent)))
normal = actual_path.get_curve_normal(20)
print("  Normal 20: {0:s}".format(str(normal)))
#
num_subdiv = actual_path.get_num_subdivisions()
print("  Number of subdivisions: {0:d}".format(num_subdiv))
subdiv_method = actual_path.get_subdivision_method()
print("  Subdivision method: {0:s}".format(subdiv_method))

# Segment along pathline

sw = sv_wrapper.SVWrapper(NET_FN)

sw.set_image(IMAGE_FN)

for i in [50]:#range(len(curve_points)):

    d = {
        "p": actual_path.get_curve_point(i), #path point
        "n": actual_path.get_curve_normal(i), #normal to the cross-sectional plane
        "tx": actual_path.get_curve_tangent(i) #tangent to the cross-sectional plane
        }

    d_s = json.dumps(d)

    ctr_pts_s = sw.segment(d_s)

    ctr_pts = json.loads(ctr_pts_s)

    print(type(ctr_pts))
    print(ctr_pts.keys())
    print(ctr_pts['points'])

# Slice at points with normal plane to get ground truth segmentations

from Code import vtk_functions as vf
import vtk

MOD_FN = '/Users/numisveinsson/Documents/Berkeley/Research/SimVascular/cases/0075_1001/Models/0075_1001.vtp'

vtk_data = vf.read_geo(MOD_FN).GetOutput()
point_data, cell_data = vf.get_all_arrays(vtk_data)

# reader = vtk.vtkXMLPolyDataReader()
# reader.SetFileName(MOD_FN)
# reader.Update()

p_0 = actual_path.get_curve_point(20)
n_0 = actual_path.get_curve_normal(50)

cut = vf.cut_plane(vtk_data, p_0, n_0)
# cut = vf.cut_plane(reader.GetOutput(), p_0, n_0)

point_data1, cell_data1 = vf.get_all_arrays(cut.GetOutput())
print(point_data1)

f_out = 'segmentation_out.vtp'
vf.write_geo(f_out, cut.GetOutput())

#############################
# Ground truth
SEG_FN = '/Users/numisveinsson/Documents/Berkeley/Research/SimVascular/VMR/segmentations/0075_1001/segmentation_200009.vtp'

# 1 way, using vtk functions
seg_data_truth = vf.read_geo(SEG_FN).GetOutput()
seg_point_data, seg_cell_data = vf.get_all_arrays(seg_data_truth)

# 2 way, using python API bindings
kernel = sv.modeling.Kernel.POLYDATA
modeler = sv.modeling.Modeler(kernel)

model = modeler.read(SEG_FN)

model_polydata = model.get_polydata()
print("Model: num nodes: {0:d}".format(model_polydata.GetNumberOfPoints()))

pdb.set_trace()

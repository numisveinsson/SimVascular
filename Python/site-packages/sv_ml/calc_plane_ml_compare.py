# Code to extract plane from .vtp segmentation

import time
start_time = time.time()
import sv
import numpy as np
import vtk
import os
import sys
import json

from Code import vtk_functions as vf
from vtk.util.numpy_support import vtk_to_numpy as v2n
from ml_analysis_functions import extract_plane, calc_seg_distance, average_vtp, points2polydata, rotate_to_plane

import modules.vascular_data as vd
#from medpy.metric.binary import dc,hd,assd

#SV_PATH = '/Users/numisveinsson/SimVascularProject/SimvascularSrc/Python/site-packages'
#sys.path.append(SV_PATH)

import sv_wrapper
# Name of NN model
NET_FN = "googlenet_c30_train300k_aug10_clean"
sw = sv_wrapper.SVWrapper(NET_FN)

##############################################################################################################################

#model = '0186_0002' # coronary
model = '0002_0001'
model = '0163_0001'
#model = '0080_0001' # pulmonary
#model = '0107_0001' # aortic

file_dir = '/Users/numisveinsson/Documents/Berkeley/Research/SimVascular/VMR/'
file_dir_image = '/Users/numisveinsson/SV_projects/svprojects/'

##############################################################################################################################

## Take in segmentation truth

SEG_FD = file_dir + 'segmentations/' + model + '/'
seg_list = os.listdir(SEG_FD)
seg_list.remove('README-COPYRIGHT.txt')

number_seg = len(seg_list)
diff_seg = []
is_junction_outside = []

results_path = []
results_cent = []

## Path to image stack, 3D, .vti or DICOM or .mha

IMAGE_FN = file_dir_image + model +'/Images/OSMSC' + model[0:4] +'-cm.vti'

## Set ML for this image stack

sw.set_image(IMAGE_FN)

for k in range(number_seg): #[seg_list.index('segmentation_200024.vtp')]:

    print('')
    print('Next segmentation:')
    print('')
    print('')
    print('SEG is')
    print(seg_list[k])
    print('')
    SEG_FN = SEG_FD + seg_list[k]

    PATH_FD = file_dir + 'paths/' + model + '/'
    path_list  = os.listdir(PATH_FD)
    path_list.remove('README-COPYRIGHT.txt')

    CENT_FN = file_dir + 'centerlines/' + model + '.vtp'

    ## Calc plane in which it lies

    normal, point_in_plane, tangent  = extract_plane(SEG_FN)

    ## Visualize vtkPlane

    np_p = np.array(point_in_plane)
    np_n = np.array(normal)
    np_t = np.array(tangent)
    plane_point = []
    for i in range(10):
        j = np_p + i*np_t
        plane_point.append(j)
    pd_plane = points2polydata(plane_point)
    vf.write_geo('plane.vtp',pd_plane)

    ## Calculate average segmentation point + ave radius

    ave_pt, ave_rad = average_vtp(SEG_FN)

    ## Locate closest centerline point to see if the segmentation is in a junction

    find_clos_object = vf.ClosestPoints(CENT_FN)
    cent_closest2ave = find_clos_object.search([np.ndarray.tolist(ave_pt)])
    cent_reader = vf.read_geo(CENT_FN)
    array = cent_reader.GetOutput().GetPointData().GetArray(0)
    array_np = v2n(array)

    is_junction_outside.append([array_np[cent_closest2ave[0]]])

    ## Take in pathlines

    inter_loc_path = []
    for name in path_list:
        if np.char.find(name,'spline') == 0:
            PATH_FN = PATH_FD + name
            #print(PATH_FN)
            vtk_data_path = vf.read_geo(PATH_FN).GetOutput()
            ## Cut each pathline with plane and store points
            cut_path = vf.cut_plane(vtk_data_path, point_in_plane, normal)
            points = v2n(cut_path.GetOutput().GetPoints().GetData())
            if np.linalg.norm(points) > 0:
                for i in points:
                    inter_loc_path.append(i)

    ## Do same for centerline

    vtk_data_cent = vf.read_geo(CENT_FN).GetOutput()
    cut_cent = vf.cut_plane(vtk_data_cent, point_in_plane, normal)
    inter_loc_cent = v2n(cut_cent.GetOutput().GetPoints().GetData())

    ## Find the intersection that belongs to our segmentation

    dist = 100000
    for i in inter_loc_path:
        vec = np.abs(i - ave_pt)
        vec_norm = np.linalg.norm(vec)
        if vec_norm < dist:
            dist = vec_norm
            pathline_point = i
    if len(pathline_point) == 1:
        pathline_point = pathline_point[0]

    pathline_point_list = np.ndarray.tolist(pathline_point)
    print("The pathline point in segmentation is")
    print(pathline_point)

    dist = 100000
    for i in inter_loc_cent:
        vec = np.abs(i - ave_pt)
        vec_norm = np.linalg.norm(vec)
        if vec_norm < dist:
            dist = vec_norm
            centerline_point = i
    print("The centerline point closest to segmentation is")
    print(centerline_point)
    centerline_point_list = np.ndarray.tolist(centerline_point)

    ## See if centerline point is within 2r from average point

    if np.linalg.norm(centerline_point - ave_pt) < 2*np.linalg.norm(point_in_plane - ave_pt) :
        is_junction_outside[k].append(0)
    else:
        is_junction_outside[k].append(-1)

    ## Save true contour in 2D

    true_seg_points = v2n(vf.read_geo(SEG_FN).GetOutput().GetPoints().GetData())
    c = true_seg_points
    p = pathline_point  # origin
    t = np.array(normal)
    tx= np.array(tangent)
    contour_norm = vd.normalizeContour(c,p,t,tx)

    ## Segment with same image using pathline point

    d = {
        "p": pathline_point_list, #path point
        "n": tangent, #normal to the cross-sectional plane
        "tx": normal #tangent to the cross-sectional plane
        }
    d_s = json.dumps(d)
    ctr_pts_s, contour_path, info = sw.segment(d_s)
    ctr_pts = json.loads(ctr_pts_s) # Returns a dictionary
    ml_prediction_path = ctr_pts['points']

    if is_junction_outside[k] == [-1,0]:
        dic = {}
        dic['name'] = seg_list[k]
        dic['points'] = ctr_pts['points']
        dic['contour'] = contour_path
        dic['info'] = info
        dic['true contour'] = contour_norm
        dic['ave radius'] = ave_rad
        dic['distance between points'] = np.linalg.norm(pathline_point-centerline_point)
        results_path.append(dic)

    ## Now centerline point

    d = {
        "p": centerline_point_list, #path point
        "n": tangent, #normal to the cross-sectional plane
        "tx": normal #tangent to the cross-sectional plane
        }
    d_s = json.dumps(d)
    ctr_pts_s, contour_cent, info = sw.segment(d_s)
    ctr_pts = json.loads(ctr_pts_s) # Returns a dictionary
    ml_prediction_cent = ctr_pts['points']
    p = centerline_point  # origin
    contour_norm = vd.normalizeContour(c,p,t,tx)
    if is_junction_outside[k] == [-1,0]:
        dic = {}
        dic['name'] = seg_list[k]
        dic['points'] = ctr_pts['points']
        dic['contour'] = contour_cent
        dic['info'] = info
        dic['true contour'] = contour_norm
        dic['ave radius'] = ave_rad
        dic['distance between points'] = np.linalg.norm(pathline_point-centerline_point)
        results_cent.append(dic)

    ## Visualize output

    pd_true_con = points2polydata(np.ndarray.tolist(contour_norm))
    pd_cent_con = points2polydata(np.ndarray.tolist(contour_cent))
    pd_path_con = points2polydata(np.ndarray.tolist(contour_path))
    vf.write_geo('true_contour.vtp',pd_true_con)
    vf.write_geo('path_contour.vtp',pd_path_con)
    vf.write_geo('cent_contour.vtp',pd_cent_con)

    pd_path = points2polydata(ml_prediction_path)
    pd_cent = points2polydata(ml_prediction_cent)
    vf.write_geo('ml_prediction_path.vtp',pd_path)
    vf.write_geo('ml_prediction_cent.vtp',pd_cent)

    ## Compare

    diff_path = calc_seg_distance(ml_prediction_path, SEG_FN)
    print('Pathline - Average distance to closest true point:')
    print(diff_path)

    diff_cent = calc_seg_distance(ml_prediction_cent, SEG_FN)
    print('Centerline - Average distance to closest true point:')
    print(diff_cent)

    diff_seg.append([k, seg_list[k], ave_rad, float(diff_path), float(diff_cent), round(100*(diff_path - diff_cent)/diff_path,1), is_junction_outside[k] ])


print(' ')
print('Calculation done')
print(' ')

np.save('results_path_'+model , results_path)
np.save('results_cent_'+model , results_cent)

print(' ')
print('Results file saved')
print(' ')

for i in diff_seg:
    print(i)

print("--- %s seconds ---" % (time.time() - start_time))
import pdb; pdb.set_trace()
